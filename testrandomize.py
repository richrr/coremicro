
from biom.table import SparseOTUTable, DenseOTUTable, table_factory, nparray_to_sparseobj
import json
from numpy import zeros, asarray, uint32, float64, random
from string import strip
import sys
#from random import shuffle

######################################################################
# READ FILE, ARG: FILENAME
# RETURN LIST
#####################################################################
def read_file(filename):
    f = open(filename)
    lines = f.readlines()
    f.close()
    #print 'Read %d lines from file %s ' %(len(lines), filename)
    return lines

# the functions you need from biom.parse

def generatedby():
    """Returns a generated by string"""
    return 'BIOM-Format %s' % "1.3.1"   #__version__ # for now manually added the version


def parse_biom_table(json_fh,constructor=None):
    """parses a biom format otu table into a rich otu table object

    input is an open filehandle or compatable object (e.g. list of lines)

    sparse/dense will be determined by "matrix_type" in biom file, and 
    either a SparseOTUTable or DenseOTUTable object will be returned
    note that sparse here refers to the compressed format of [row,col,count]
    dense refers to the full / standard matrix representations

    If try_light_parse is True, the light_parse_biom_sparse call will be 
    attempted. If that parse fails, the code will fall back to the regular
    BIOM parser.
    """
    table_str = ''.join(json_fh)

    t = parse_biom_table_str(table_str, constructor=constructor)
    return t

def parse_biom_table_str(json_str,constructor=None, data_pump=None):
    """Parses a JSON string of the Biom table into a rich table object.
   
    If constructor is none, the constructor is determined based on BIOM
    information

    data_pump is to allow the injection of a pre-parsed data object
    """
    json_table = json.loads(json_str)

    if constructor is None:
        f = BIOM_TYPES.get(json_table['type'].lower(), None)
    else:
        f = BIOM_TYPES.get(constructor._biom_type.lower(), None)

        # convert matrix data if the biom type doesn't match matrix type
        # of the table objects
        if constructor._biom_matrix_type != json_table['matrix_type'].lower():
            if json_table['matrix_type'] == 'dense':
                # dense -> sparse
                conv_data = []
                for row_idx,row in enumerate(json_table['data']):
                    for col_idx, value in enumerate(row):
                        if value == 0:
                            continue
                        conv_data.append([row_idx,col_idx,value])
                json_table['data'] = conv_data

            elif json_table['matrix_type'] == 'sparse':
                # sparse -> dense
                conv_data = zeros(json_table['shape'],dtype=float)
                for r,c,v in json_table['data']:
                    conv_data[r,c] = v
                json_table['data'] = [list(row) for row in conv_data]

            else:
                raise BiomParseException, "Unknown matrix_type"

    if f is None:
        raise BiomParseException, 'Unknown table type'

    return f(json_table, constructor, data_pump)

def convert_biom_to_table(biom_f, header_key=None, header_value=None, \
        md_format=None):
    """Convert a biom table to a contigency table"""
    table = parse_biom_table(biom_f)

    if md_format is None:
        md_format = biom_meta_to_string

    if table.ObservationMetadata is None:
        return table.delimitedSelf()
    
    if header_key in table.ObservationMetadata[0]:
        return table.delimitedSelf(header_key=header_key, 
                                       header_value=header_value,
                                       metadata_formatter=md_format)
    else:
        return table.delimitedSelf()


def pick_constructor(mat_type, table_type, constructor, valid_constructors):
    """Make sure constructor is sane, attempt to pick one if not specified

    Excepts valid_constructors to be a list in the order of 
    [SparseTable, DenseTable] in which the objects present must subclass the
    objects respectively (eg [SparseOTUTable, DenseOTUTable])

    We do not require the matrix type to be the same as the constructor if the 
    passed in constructor is not None. The motivation is that there are use
    cases for taking a table stored as dense but loaded as sparse.

    Will raise BiomParseError if input_mat_type appears wrong or if the 
    specified constructor appears to be incorrect
    """
    if constructor is None:
        if mat_type.lower() == 'sparse':
            constructor = valid_constructors[0]
        elif mat_type.lower() == 'dense':
            constructor = valid_constructors[1]
        else:
            raise BiomParseException, "Unknown matrix_type"

    if constructor._biom_type.lower() != table_type.lower():
        raise BiomParseException, "constructor must be a biom %s" % table_type

    return constructor


def parse_biom_otu_table(json_table, constructor=None, data_pump=None):
    """Parse a biom otu table type

    Constructor must have a _biom_type of "otu table"
    """
    table_type = 'otu table'
    mat_type = json_table['matrix_type']
    constructors = [SparseOTUTable, DenseOTUTable]
    constructor = pick_constructor(mat_type,table_type,constructor,constructors)

    sample_ids = [col['id'] for col in json_table['columns']]
    sample_metadata = [col['metadata'] for col in json_table['columns']]
    obs_ids = [row['id'] for row in json_table['rows']]
    obs_metadata = [row['metadata'] for row in json_table['rows']]
    dtype = MATRIX_ELEMENT_TYPE[json_table['matrix_element_type']]

    if data_pump is None:
        table_obj = table_factory(json_table['data'], sample_ids, obs_ids, 
                                  sample_metadata, obs_metadata, 
                                  constructor=constructor, 
                                  shape=json_table['shape'], 
                                  dtype=dtype)
    else:
        table_obj = table_factory(data_pump, sample_ids, obs_ids, 
                                  sample_metadata, obs_metadata, 
                                  constructor=constructor, 
                                  shape=json_table['shape'], 
                                  dtype=dtype)

    return table_obj


# convert biom to table
def main_converter(input_fp, header_key, biom_to_classic_table=True):
    
    if input_fp is None:
        return ('Must specify an input file!')

    input_f = input_fp    
    output_metadata_id = header_key

    if biom_to_classic_table:
        try:
            return(convert_biom_to_table(input_f, header_key, output_metadata_id, lambda x: x)) # to avoid every character in taxonomy being split and joined by '; '
        except ValueError:
            raise ValueError, "Input does not look like a .biom file. Did you accidentally specify -b?"


# convert table to biom
def convert_table_to_biom(table_f,sample_mapping, obs_mapping, process_func, constructor,
                          **kwargs):
    """Convert a contigency table to a biom table
    
    sample_mapping : dict of {'sample_id':metadata} or None
    obs_mapping : dict of {'obs_id':metadata} or None
    process_func: a function to transform observation metadata
    constructor : a biom table type
    dtype : type of table data
    """
    otu_table = parse_classic_table_to_rich_table(table_f, sample_mapping, 
                                                  obs_mapping, process_func,
                                                  constructor, **kwargs)
    return otu_table.getBiomFormatJsonString(generatedby())


## biom convert -i otu_table_mc2_w_tax_no_pynast_failures.biom.txt -o otu_table_mc2_w_tax_no_pynast_failures_biom_to_txt_to_biom.biom --table-type="otu table"

def parse_classic_table_to_rich_table(lines, sample_mapping, obs_mapping, process_func,
        constructor, **kwargs):
    """Parses an table (tab delimited) (observation x sample)

    sample_mapping : can be None or {'sample_id':something}
    obs_mapping : can be none or {'observation_id':something}
    """
    sample_ids, obs_ids, data, t_md, t_md_name = parse_classic_table(lines, 
                                                        **kwargs)
    #print sample_ids, obs_ids, data, t_md, t_md_name

    # if we have it, keep it
    if t_md is None:
        obs_metadata = None
    else:
        obs_metadata = [{t_md_name:process_func(v)} for v in t_md]

    if sample_mapping is None:
        sample_metadata = None
    else:
        sample_metadata = [sample_mapping[sample_id] for sample_id in sample_ids]

    # will override any metadata from parsed table
    if obs_mapping is not None:
        obs_metadata = [obs_mapping[obs_id] for obs_id in obs_ids]

    if constructor._biom_matrix_type == 'sparse':
        data = nparray_to_sparseobj(data)
    
    return table_factory(data, sample_ids, obs_ids, sample_metadata, 
                         obs_metadata, constructor=constructor)

def parse_classic_table(lines, delim='\t', dtype=float, header_mark=None, \
        md_parse=None):
    """Parse a classic table into (sample_ids, obs_ids, data, metadata, md_name)

    If the last column does not appear to be numeric, interpret it as 
    observation metadata, otherwise None.

    md_name is the column name for the last column if non-numeric

    NOTE: this is intended to be close to how QIIME classic OTU tables are
    parsed with the exception of the additional md_name field

    This function is ported from QIIME (http://www.qiime.org), previously named
    parse_classic_otu_table. QIIME is a GPL project, but we obtained permission
    from the authors of this function to port it to the BIOM Format project
    (and keep it under BIOM's BSD license).
    """
    if not isinstance(lines, list):
        try:
            lines = lines.readlines()
        except AttributeError:
            raise BiomParseException, "Input needs to support readlines or be indexable"

    # find header, the first line that is not empty and does not start with a #
    for idx,l in enumerate(lines):
        if not l.strip():
            continue
        if not l.startswith('#'):
            break
        if header_mark and l.startswith(header_mark):
            break

    if idx == 0:
        data_start = 1
        header = lines[0].strip().split(delim)[1:]
    else:
        if header_mark is not None:
            data_start = idx + 1
            header = lines[idx].strip().split(delim)[1:]
        else:
            data_start = idx
            header = lines[idx-1].strip().split(delim)[1:]

    # attempt to determine if the last column is non-numeric, ie, metadata
    first_values = lines[data_start].strip().split(delim)
    last_value = first_values[-1]
    last_column_is_numeric = True

    if '.' in last_value:
        try:
            float(last_value)
        except ValueError:
            last_column_is_numeric = False
    else:
        try:
            int(last_value)
        except ValueError:
            last_column_is_numeric = False
    
    # determine sample ids
    if last_column_is_numeric:
        md_name = None
        metadata = None
        samp_ids = header[:]
    else:
        md_name = header[-1]
        metadata = []
        samp_ids = header[:-1]
    
    data = []
    obs_ids = []
    for line in lines[data_start:]:
        line = line.strip()
        if not line:
            continue
        if line.startswith('#'):
            continue

        fields = line.strip().split(delim)
        obs_ids.append(fields[0])

        if last_column_is_numeric:
            values = map(dtype, fields[1:])
        else:
            values = map(dtype, fields[1:-1])

            if md_parse is not None:
                metadata.append(md_parse(fields[-1]))
            else:
                metadata.append(fields[-1])

        data.append(values)

    return samp_ids, obs_ids, asarray(data), metadata, md_name


def convert_back_to_biom(headers, l_taxo_otuid_dict, l_rand_taxo_dataset_dict):
    delim = '\t'
    lines_for_biom = [x for x in headers]

    # convert the dictionary to list of lines (similar to what biom -> otu table gives you)
    for taxonom , v in l_rand_taxo_dataset_dict.items():
        str = "%s\t%s\t%s" %(l_taxo_otuid_dict[taxonom] , delim.join(v) , taxonom)
        lines_for_biom.append(str)

    # convert the list of lines to biom format
    
    # table to biom
    MatrixTypes = ['sparse', 'dense']

    TableTypes = {'otu table': [SparseOTUTable, DenseOTUTable]}

    ObservationMetadataTypes = {
            'sc_separated': lambda x: [e.strip() for e in x.split(';')],
            'naive': lambda x: x
    }
    ObservationMetadataTypes['taxonomy'] = ObservationMetadataTypes['sc_separated']

    table_type = 'otu table'
    matrix_type = 'sparse'
    idx = 0 if matrix_type == 'sparse' else 1
    constructor = TableTypes[table_type][idx]

    return convert_table_to_biom(lines_for_biom, None, None, ObservationMetadataTypes['naive'], constructor)
    

# map table types -> parsing methods
BIOM_TYPES = {'otu table':parse_biom_otu_table}

MATRIX_ELEMENT_TYPE = {'int':int,'float':float,'unicode':unicode,
                      u'int':int,u'float':float,u'unicode':unicode}

QUOTE = '"'
JSON_OPEN = set(["[", "{"])
JSON_CLOSE = set(["]", "}"])
JSON_SKIP = set([" ","\t","\n",","])
JSON_START = set(["0","1","2","3","4","5","6","7","8","9","{","[",'"'])



# read a biom file as a list of lines
biom_list_of_lines = read_file("static/sample_data/otu_table_16s.biom")  ### USER INPUT

# convert to classical table
otu_table = main_converter(biom_list_of_lines, header_key="taxonomy")  ### USER INPUT
#print otu_table


# allowed randomization options: 
# rowWise: for each row (otu), shuffles the numbers ((slowest))
# otuLabel: keeps the data table and sample annotation the same, only shuffles the otu taxonomies (labels)
# sampAnnot: keeps the data table and otu labels the same, only shuffles the sample annotations ((default))

# colWise: for each column (sample), shuffles the numbers ((Not implemented))
# wholeTable: shuffles all the values as rows and columns; keeps the sample annotations and otu labels the same ((Not implemented))


header_lines = list()

taxo_dataset_dict = dict()  # taxonomy is the key; digits is value
taxo_otuid_dict = dict() # taxonomy is the key; otu id (number) is value

otuid_idx = ''
taxo_idx = ''

biom_file = ''

ignore_idx = []
for otu in otu_table.split('\n'):
    #print otu
    otu = otu.strip()
    
    if '#' in otu or otu == '':
        header_lines.append(otu)
        if '#OTU ID' in otu:
            otuid_idx = otu.split('\t').index('#OTU ID')
            ignore_idx.append(otuid_idx)
        if 'taxonomy' in otu:
            taxo_idx = otu.split('\t').index('taxonomy')
            ignore_idx.append(taxo_idx)
        #sys.exit(0)
        continue
    
    vals = otu.split('\t')
    digits = [vals[idx] for idx in range(len(vals)) if idx not in ignore_idx]
    
    # make sure right at the start that the taxonomies (otu labels) are unique.
    taxo_dataset_dict[vals[taxo_idx]] = digits
    taxo_otuid_dict[vals[taxo_idx]] = vals[otuid_idx]

randomizeOpt = 'rowWise'  ### USER INPUT


rand_taxo_dataset_dict = dict()
if randomizeOpt == 'rowWise':
    ## USER INPUT  Write an outer for loop to do this for n randomizations
    for k, v in taxo_dataset_dict.items():
        b = v[:]  # creates a new separate copy for in-place shuffling
        random.shuffle(b) # uses numpy's shuffle which is thought to be slightly faster
        rand_taxo_dataset_dict[k] = b
    biom_file = convert_back_to_biom(header_lines, taxo_otuid_dict, rand_taxo_dataset_dict)

elif randomizeOpt == 'otuLabel':
    ## USER INPUT  Write an outer for loop to do this for n randomizations
    keys = taxo_dataset_dict.keys()
    random.shuffle(keys)
    rand_taxo_dataset_dict = dict(zip(keys, taxo_dataset_dict.values()))
    biom_file = convert_back_to_biom(header_lines, taxo_otuid_dict, rand_taxo_dataset_dict)

else:
    print "run default"


print biom_file